//converte o resultado binário de 8 bits para Hex, Dec ou Octal
module decodificador_de_base (
    input [7:0] resultado_bin,	// resultado da ULA (8 bits)
    input [1:0] base_selecionada,		// 00=Hex, 01=Dec, 10=Oct
    
    // Saídas dos 7 segmentos (Anodo Comum) para 3 displays
    output reg [6:0] hex0_segments, // Display 0 (unidades/LSB)
    output reg [6:0] hex1_segments, // Display 1 (dezenas/MSB)
    output reg [6:0] hex2_segments, // Display 2 (centenas/mais à esquerda)
    
    // LEDs de indicação da base (opcional)
    output reg [2:0] base_leds
);

    // Sinais internos para as diferentes bases
    // HEXADECIMAL (8 bits = 2 dígitos de 4 bits)
    wire [3:0] hex_low = resultado_bin[3:0];
    wire [3:0] hex_high = resultado_bin[7:4];
    wire [6:0] hex_seg_l, hex_seg_h;

    // DECIMAL (8 bits, máx 255 = 3 dígitos BCD)
    wire [3:0] dec_units, dec_tens, dec_hundreds;
    wire [6:0] dec_seg_u, dec_seg_t, dec_seg_h;

    // OCTAL (8 bits, máx 377 = 3 dígitos de 3 bits)
    wire [2:0] oct_low = resultado_bin[2:0];    // O1 (Unidades)
    wire [2:0] oct_mid = resultado_bin[5:3];    // O2 (8)
    wire [1:0] oct_high = resultado_bin[7:6];   // O3 (64)
    wire [6:0] oct_seg_l, oct_seg_m, oct_seg_h;

	 
    always @(*) begin
        // Centenas
        if (resultado_bin >= 8'd200) dec_hundreds = 4'd2;
        else if (resultado_bin >= 8'd100) dec_hundreds = 4'd1;
        else dec_hundreds = 4'd0;

        // Valor restante após as centenas
        integer temp_val;
        temp_val = resultado_bin - dec_hundreds * 100;
        
        // Dezenas
        dec_tens = temp_val / 10;
        
        // Unidades
        dec_units = temp_val % 10;
    end
    
    // 2. Instâncias do Decodificador 4-bit para 7-Segmentos
    
    // Decodificadores Hexadecimais
    decodificador_4bitx7seg hex_dec_l (.data_in(hex_low),  .segments(hex_seg_l));
    decodificador_4bitx7seg hex_dec_h (.data_in(hex_high), .segments(hex_seg_h));

    // Decodificadores Decimais
    decodificador_4bitx7seg dec_dec_u (.data_in(dec_units),    .segments(dec_seg_u));
    decodificador_4bitx7seg dec_dec_t (.data_in(dec_tens),     .segments(dec_seg_t));
    decodificador_4bitx7seg dec_dec_h (.data_in(dec_hundreds), .segments(dec_seg_h));

    // Decodificadores Octais (Requerem zero padding para 4 bits)
    // O3 (MSB) = [0, Result[7:6]]
    decodificador_4bitx7seg oct_dec_h (.data_in({2'b0, oct_high}), .segments(oct_seg_h));
    // O2 = [0, Result[5:3]]
    decodificador_4bitx7seg oct_dec_m (.data_in({1'b0, oct_mid}),  .segments(oct_seg_m));
    // O1 (LSB) = [0, Result[2:0]]
    decodificador_4bitx7seg oct_dec_l (.data_in({1'b0, oct_low}),  .segments(oct_seg_l));

    // MUX da Saída
    always @(*) begin
        // Padrão: apaga todos os displays
        hex2_segments = 7'b1111111; // Display mais à esquerda (HEX2)
        hex1_segments = 7'b1111111; // Display do meio (HEX1)
        hex0_segments = 7'b1111111; // Display menos à esquerda (HEX0)
        base_leds = 3'b000;         // Apaga LEDs de base

        case (base_selecionada)
            
            // Base 00: HEXADECIMAL (Exibe em HEX1 e HEX0)
            2'b00: begin
                // Dígito MSB do Hex -> HEX1
                hex1_segments = hex_seg_h; 
                // Dígito LSB do Hex -> HEX0
                hex0_segments = hex_seg_l;
                // LED de indicação de Hex
                base_leds = 3'b100; // Por exemplo, LED2 aceso
            end
            
            // Base 01: DECIMAL (Exibe em HEX2, HEX1 e HEX0)
            2'b01: begin
                // Centenas (max 2) -> HEX2
                hex2_segments = dec_seg_h;
                // Dezenas -> HEX1
                hex1_segments = dec_seg_t;
                // Unidades -> HEX0
                hex0_segments = dec_seg_u;
                // LED de indicação de Decimal
                base_leds = 3'b010; // Por exemplo, LED1 aceso
            end
            
            // Base 10: OCTAL (Exibe em HEX2, HEX1 e HEX0)
            2'b10: begin
                // O3 (MSB) -> HEX2
                hex2_segments = oct_seg_h;
                // O2 (Meio) -> HEX1
                hex1_segments = oct_seg_m;
                // O1 (LSB) -> HEX0
                hex0_segments = oct_seg_l;
                // LED de indicação de Octal
                base_leds = 3'b001; // Por exemplo, LED0 aceso
            end

            // Default
            default: begin
                hex2_segments = 7'b1111111;
                hex1_segments = 7'b1111111;
                hex0_segments = 7'b1111111;
                base_leds = 3'b000;
            end
            
        endcase
    end

endmodule
